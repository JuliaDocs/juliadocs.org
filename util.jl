"""
Generates a default documentation for a package without a docs folder
"""
function default_docs(package, root, pkgroot)
    doc_source = joinpath(root, "src")
    mkpath(doc_source)
    open(joinpath(doc_source, "autodocs.md"), "w") do io
        println(io, """
        Package doesn't contain Documenter docs.

        Docs automatically generated by juliadocs.org

        ```@autodocs
        Modules = [$package]
        Order = [:type, :function]
        ```
        """)
    end
    pages = ["Docstrings" => "autodocs.md"]
    readme = joinpath(pkgroot, "README.md")
    if isfile(readme)
        cp(readme, joinpath(doc_source, "index.md"))
        push!(pages, "Readme" => "index.md")
    end
    pkg_sym = Symbol(package)
    @eval Module() begin
        using Documenter
        using $pkg_sym
        makedocs(
            format = Documenter.HTML(),
            sitename = "$($package).jl",
            modules = [$pkg_sym],
            root = $root,
            pages = $(reverse(pages))
        )
    end
end

function parseall(str)
    pos = firstindex(str)
    exs = []
    while pos <= lastindex(str)
        ex, pos = Meta.parse(str, pos)
        push!(exs, ex)
    end
    if length(exs) == 0
        throw(ParseError("end of input"))
    elseif length(exs) == 1
        return exs[1]
    else
        return Expr(:block, exs...)
    end
end

"""
Rewrites the docs/make.jl for a given package to not deploy and respect
our build folders. This respects any custom scripts needed to build the docs
while disabling deploy + putting the right args into makedocs
"""
function rewrite_makefile(makefile)
    ast = parseall(read(makefile, String))
    make_expr = Expr(:block)
    buildpath = joinpath(dirname(makefile), "build")
    for elem in ast.args
        # skip deply(...) - we don't want to deploy
        Meta.isexpr(elem, :call) && elem.args[1] == :deploydocs && continue
        if Meta.isexpr(elem, :call) && elem.args[1] == :makedocs
            # rewrite makedoc call to respect our requirements
            new_args = []
            for argument in elem.args
                if Meta.isexpr(argument, :kw)
                    name, arg = argument.args
                    # assure that we generate HTML
                    if name == :format
                        argument.args[2] = :(Documenter.HTML())
                    end
                    # filter out root + build dir
                    if name == :build
                        # if there is a custom build folder, record it!
                        cd(dirname(makefile)) do
                            # uhm, joinpath(path1, path2) doesn't work...
                            # considering splitting this mayself, but this seems
                            # to be the easiest way to get the abspath respecting
                            # build path needs to be relative to root path
                            buildpath = abspath(arg)
                        end
                    end
                end
                push!(new_args, argument)
            end
            push!(new_args,
                Expr(:kw, :root, dirname(makefile)),
            )
            elem = Expr(:call, new_args...)
        end
        push!(make_expr.args, elem)
    end
    return make_expr, buildpath
end

struct PkgNoWork <: Exception
    name::String
end

function install_and_use(pspec)
    # add dependencies as well? will be trivial with a package containing Project.toml
    try
        Pkg.add(pspec)
    catch e
        throw(PkgNoWork(pspec.name))
    end
    pkg_sym = Symbol(pspec.name)
    # needs to be main, because documenter wants to have the symbol in main -.-
    pkg_module = try
        @eval(Main, (using $pkg_sym; $pkg_sym))
    catch e
        throw(PkgNoWork(pspec.name))
    end
    pkg_root = normpath(joinpath(dirname(pathof(pkg_module)), ".."))
    pkg_module, pkg_root
end

function run_with_timeout(
        command, timeout, logfile, name;
        out_io = IOBuffer(), err_io = IOBuffer(),
        wait_time = 0.5
    )
    pipe = pipeline(command, stdout = out_io, stderr = err_io)
    process = run(pipe, wait = false)
    timeout_start = time()
    logs = Pair{Symbol, String}[]
    killed = false
    task = @async begin
        tstart = time()
        while process_running(process)
            elapsed = (time() - timeout_start)
            if elapsed > timeout
                @info("killing build for $name")
                kill(process); killed = true
                break
            end
            is_silent = true
            if bytesavailable(out_io) > 0
                push!(logs, :out => read(out_io, String)); is_silent = false
            end
            if bytesavailable(err_io) > 0
                push!(logs, :out => read(err_io, String)); is_silent = false
            end
            # if something printed reset timeout
            if !is_silent
                println("resetting")
                timeout_start = time()
            end
            sleep(wait_time)
        end
        killed || @info("build for $name completed in $(time() - tstart) seconds")
        println(length(logs))
        open(logfile, "w") do io
            for (typ, msg) in logs
                println(io, typ, ">", msg)
            end
        end
    end
    return process, task
end



function run_process(name, url, version)
    out_io = Pipe()
    err_io = Pipe()
    cmd = `julia --compiled-modules=no --startup-file=no -O0 -g2 worker_work.jl $name $url $version`
    @info("starting build for $name")
    process = run(pipeline(cmd, stdout = out_io, stderr = err_io), wait = false)
    timeout_start = time()
    buildpath = joinpath(@__DIR__, "build", name)
    task = @async begin
        try
            tstart = time()
            isdir(buildpath) && rm(buildpath, force = true, recursive = true)
            mkpath(buildpath)
            open(joinpath(buildpath, "build.log"), "w") do log
                while process_running(process)
                    if (time() - timeout_start) > build_timeout
                        @info("killing build for $name")
                        kill(process)
                        break
                    end
                    errstr, outstr = read.((err_io, out_io), (String,))
                    is_silent = length(errstr) == 0 && length(outstr) == 0
                    isempty(outstr) || println(log, outstr)
                    isempty(errstr) || println(log, errstr)
                    if !is_silent
                        # if something printed reset timeout
                        timeout_start = time()
                    end
                    sleep(0.5)
                end
            end
            @info("build for $name completed in $(time() - tstart) seconds")
        catch e
            @error("Bad stuff!", error = e)
        end
    end
    return process
end
